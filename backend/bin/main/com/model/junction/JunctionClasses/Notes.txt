// Thoughts
// Each quarter has its own greenElapsed variable which shows how long the green light for a certain junction has been active
// this number could have some sort of hard limit, like say 1 minute in real life.
// in this duration, keep subtracting from the queues.

// would we have some sort of priority? Like if there is one junction quarter that would be next in turn however there is another quarter suffering
// quite a bit maybe it would be best to turn that one green instead and then the one with loewr priority would be lower, so maybe we could give
// each quarter some sort of urgency weighting.

// For now this simulation logic will cover a single junction quarter with 5 lanes. Extending it should be easy enough by just doing 4 quarters instead of 1

/* 
CONFIGURABLE PARAMETER NOTE: Number of Lanes --------------------------------------------------------------------------------------------------------
 
For the number of lanes, we will have to change the for loops because currently we are assuming there's a forwards lane, right turning lane and
a left turn/forwards lane which means the configurable parameter has been set to 3. With 5 lanes there will be 3 forwards lanes, 1 left/forwards lane
and then 1 right turn lane. Maybe we could change the right turn lane so that it is also a forwards lane.
*/

/* 
CONFIGURABLE PARAMETER NOTE: Left Turn Lane ----------------------------------------------------------------------------------------------------------

We might have to change the threading here a bit and call a new thread which is solely for cars in the left turn lane exiting the junction and this
will be called when the opposing lane has a green light. 
*/

/* 
CONFIGURABLE PARAMETER NOTE: Bus/Cycle Lane ----------------------------------------------------------------------------------------------------------
The bus lane will work by essentially funcitoning as a left turn lane and if it allows buses to go forwards or to the right then cars wont't
be allowed to go left and if it allows buses to go right then cars on the right side lanes can only go right too.

*/

/* 
CONFIGURABLE PARAMETER NOTE: Pedestrian Crossing ------------------------------------------------------------------------------------------------------

See the TODO below on changing the car outflow into a runnable

*/

/* 
CONFIGURABLE PARAMETER NOTE: Prioritised traffic flow -------------------------------------------------------------------------------------------------

What I think this is is just the order in which the traffic lights will be on so we can order it so that it is N, E, S, W or if we want to prioritise traffic 
coming from the west then we could say W, N, E, S where W (west) will be the first traffic light to turn green and then north then east and finally south
*/

/* 
TODO: To further extend this solution, I believe that turning the cars exiting thread into a runnable so we can adjust the time between calls to take
into account the fact that we will have to implement a pedestrian crossing where there will not be a constant trafic light green time. So it won't be every
minute for example it will be maybe once a minute and then with the crossing, add another minute to it so that the next call takes place in two.

*/




// Car entering task using recursive scheduling
        Runnable enterCarsTask = new Runnable() {
            @Override
            public void run() {
                if (carsEntering.isShutdown()) {
                    return;
                }
                
                // Generate Poisson-distributed number of cars for each lane
                int carsEast = generatePoisson((int) exitingEast/240);
                int carsNorth = generatePoisson((int) exitingNorth/240);
                int carsWest = generatePoisson((int) exitingWest/240);

                // Add cars to each lane
                for (int i = 0; i < carsEast; i++) {
                    outboundCars[0].add(System.nanoTime());
                }
               
                for (int i = 0; i < carsNorth; i++) {
                    if (outboundCars[1].size() > outboundCars[2].size() && outboundCars[1].size() > 30) {
                        outboundCars[2].add(System.nanoTime());
                    } else {
                        outboundCars[1].add(System.nanoTime());
                    }
                }

                for (int i = 0; i < carsWest / 60; i++) {
                    outboundCars[2].add(System.nanoTime());
                }

                // Generate the next arrival time (negative Exponential Distribution)
                interArrivalTime = -Math.log(1.0 - random.nextDouble()) / ((3600.0 / northboundVph));
                exponentialTimeInterval = (long) (interArrivalTime * 2 * 1000);

                // Reschedule the next entry
                carsEntering.schedule(this, exponentialTimeInterval, TimeUnit.MILLISECONDS);
            }
        };
        
        // Start entering cars
        carsEntering.schedule(enterCarsTask, 0, TimeUnit.MILLISECONDS);

        /* Modification End */


        
    }

    /*'additional method' generating poisson dist */

    // Poisson distribution generator(this algorithm proposed by D. Knuth:)
    private static int generatePoisson(int lambda) {
        double L = Math.exp(-lambda); 
        double p = 1.0;
        int k = 0;

        // Keep generating Poisson until p < L
        do {
            k++;
            p *= random.nextDouble();
        } while (p > L);

        return k - 1;
    } 